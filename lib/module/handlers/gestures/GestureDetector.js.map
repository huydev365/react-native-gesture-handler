{"version":3,"sources":["GestureDetector.tsx"],"names":["React","useEffect","useRef","BaseGesture","CALLBACK_TYPE","Reanimated","registerHandler","unregisterHandler","RNGestureHandlerModule","baseGestureHandlerWithMonitorProps","filterConfig","findNodeHandle","GestureStateManager","flingGestureHandlerProps","forceTouchGestureHandlerProps","longPressGestureHandlerProps","panGestureHandlerProps","panGestureHandlerCustomNativeProps","tapGestureHandlerProps","State","EventType","ALLOWED_PROPS","convertToHandlerTag","ref","handlerTag","current","extractValidHandlerTags","interactionGroup","map","filter","tag","dropHandlers","preparedGesture","handler","config","dropGestureHandler","testId","attachHandlers","gestureConfig","gesture","viewTag","useAnimated","firstExecution","initialize","setImmediate","prepare","createGestureHandler","handlerName","requireToFail","simultaneousWith","updateGestureHandler","simultaneousHandlers","waitFor","attachGestureHandler","animatedHandlers","value","g","handlers","updateHandlers","i","length","needsToReattach","useAnimatedGesture","needsRebuild","isStateChangeEvent","event","oldState","isTouchEvent","eventType","getHandler","type","BEGAN","onBegin","START","onStart","UPDATE","onUpdate","CHANGE","onChange","END","onEnd","FINALIZE","onFinalize","TOUCHES_DOWN","onTouchesDown","TOUCHES_MOVE","onTouchesMove","TOUCHES_UP","onTouchesUp","TOUCHES_CANCELLED","onTouchesCancelled","touchEventTypeToCallbackType","UNDEFINED","runWorklet","args","isWorklet","console","warn","sharedHandlersCallbacks","useSharedValue","lastUpdateEvent","stateControllers","callback","currentCallback","UNDETERMINED","state","ACTIVE","undefined","FAILED","CANCELLED","create","changeEventCalculator","useEvent","animatedEventHandler","GestureDetector","props","toGestureArray","find","reduce","prev","viewRef","firstRenderRef","Error","needsToRebuildReanimatedEvent","children","Wrap","Component","render","child","Children","only","cloneElement","collapsable","AnimatedWrap","default","createAnimatedComponent"],"mappings":"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","sourcesContent":["import React, { useEffect, useRef } from 'react';\r\nimport {\r\n  GestureType,\r\n  HandlerCallbacks,\r\n  BaseGesture,\r\n  GestureRef,\r\n  CALLBACK_TYPE,\r\n} from './gesture';\r\nimport { Reanimated, SharedValue } from './reanimatedWrapper';\r\nimport { registerHandler, unregisterHandler } from '../handlersRegistry';\r\nimport RNGestureHandlerModule from '../../RNGestureHandlerModule';\r\nimport {\r\n  baseGestureHandlerWithMonitorProps,\r\n  filterConfig,\r\n  findNodeHandle,\r\n  GestureTouchEvent,\r\n  GestureUpdateEvent,\r\n  GestureStateChangeEvent,\r\n} from '../gestureHandlerCommon';\r\nimport {\r\n  GestureStateManager,\r\n  GestureStateManagerType,\r\n} from './gestureStateManager';\r\nimport { flingGestureHandlerProps } from '../FlingGestureHandler';\r\nimport { forceTouchGestureHandlerProps } from '../ForceTouchGestureHandler';\r\nimport { longPressGestureHandlerProps } from '../LongPressGestureHandler';\r\nimport {\r\n  panGestureHandlerProps,\r\n  panGestureHandlerCustomNativeProps,\r\n} from '../PanGestureHandler';\r\nimport { tapGestureHandlerProps } from '../TapGestureHandler';\r\nimport { State } from '../../State';\r\nimport { EventType } from '../../EventType';\r\nimport { ComposedGesture } from './gestureComposition';\r\n\r\nconst ALLOWED_PROPS = [\r\n  ...baseGestureHandlerWithMonitorProps,\r\n  ...tapGestureHandlerProps,\r\n  ...panGestureHandlerProps,\r\n  ...panGestureHandlerCustomNativeProps,\r\n  ...longPressGestureHandlerProps,\r\n  ...forceTouchGestureHandlerProps,\r\n  ...flingGestureHandlerProps,\r\n];\r\n\r\nexport type GestureConfigReference = {\r\n  config: GestureType[];\r\n  animatedEventHandler: unknown;\r\n  animatedHandlers: SharedValue<\r\n    HandlerCallbacks<Record<string, unknown>>[] | null\r\n  > | null;\r\n  firstExecution: boolean;\r\n  useAnimated: boolean;\r\n};\r\n\r\nfunction convertToHandlerTag(ref: GestureRef): number {\r\n  if (typeof ref === 'number') {\r\n    return ref;\r\n  } else if (ref instanceof BaseGesture) {\r\n    return ref.handlerTag;\r\n  } else {\r\n    // @ts-ignore in this case it should be a ref either to gesture object or\r\n    // a gesture handler component, in both cases handlerTag property exists\r\n    return ref.current?.handlerTag ?? -1;\r\n  }\r\n}\r\n\r\nfunction extractValidHandlerTags(interactionGroup: GestureRef[] | undefined) {\r\n  return (\r\n    interactionGroup?.map(convertToHandlerTag)?.filter((tag) => tag > 0) ?? []\r\n  );\r\n}\r\n\r\nfunction dropHandlers(preparedGesture: GestureConfigReference) {\r\n  for (const handler of preparedGesture.config) {\r\n    RNGestureHandlerModule.dropGestureHandler(handler.handlerTag);\r\n\r\n    unregisterHandler(handler.handlerTag, handler.config.testId);\r\n  }\r\n}\r\n\r\ninterface AttachHandlersConfig {\r\n  preparedGesture: GestureConfigReference;\r\n  gestureConfig: ComposedGesture | GestureType | undefined;\r\n  gesture: GestureType[];\r\n  viewTag: number;\r\n  useAnimated: boolean;\r\n}\r\n\r\nfunction attachHandlers({\r\n  preparedGesture,\r\n  gestureConfig,\r\n  gesture,\r\n  viewTag,\r\n  useAnimated,\r\n}: AttachHandlersConfig) {\r\n  if (!preparedGesture.firstExecution) {\r\n    gestureConfig?.initialize();\r\n  } else {\r\n    preparedGesture.firstExecution = false;\r\n  }\r\n\r\n  // use setImmediate to extract handlerTags, because all refs should be initialized\r\n  // when it's ran\r\n  setImmediate(() => {\r\n    gestureConfig?.prepare();\r\n  });\r\n\r\n  for (const handler of gesture) {\r\n    RNGestureHandlerModule.createGestureHandler(\r\n      handler.handlerName,\r\n      handler.handlerTag,\r\n      filterConfig(handler.config, ALLOWED_PROPS)\r\n    );\r\n\r\n    registerHandler(handler.handlerTag, handler, handler.config.testId);\r\n\r\n    // use setImmediate to extract handlerTags, because all refs should be initialized\r\n    // when it's ran\r\n    setImmediate(() => {\r\n      let requireToFail: number[] = [];\r\n      if (handler.config.requireToFail) {\r\n        requireToFail = extractValidHandlerTags(handler.config.requireToFail);\r\n      }\r\n\r\n      let simultaneousWith: number[] = [];\r\n      if (handler.config.simultaneousWith) {\r\n        simultaneousWith = extractValidHandlerTags(\r\n          handler.config.simultaneousWith\r\n        );\r\n      }\r\n\r\n      RNGestureHandlerModule.updateGestureHandler(\r\n        handler.handlerTag,\r\n        filterConfig(handler.config, ALLOWED_PROPS, {\r\n          simultaneousHandlers: simultaneousWith,\r\n          waitFor: requireToFail,\r\n        })\r\n      );\r\n    });\r\n  }\r\n  preparedGesture.config = gesture;\r\n\r\n  for (const gesture of preparedGesture.config) {\r\n    RNGestureHandlerModule.attachGestureHandler(\r\n      gesture.handlerTag,\r\n      viewTag,\r\n      !useAnimated // send direct events when using animatedGesture, device events otherwise\r\n    );\r\n  }\r\n\r\n  if (preparedGesture.animatedHandlers) {\r\n    preparedGesture.animatedHandlers.value = (gesture.map(\r\n      (g) => g.handlers\r\n    ) as unknown) as HandlerCallbacks<Record<string, unknown>>[];\r\n  }\r\n}\r\n\r\nfunction updateHandlers(\r\n  preparedGesture: GestureConfigReference,\r\n  gestureConfig: ComposedGesture | GestureType | undefined,\r\n  gesture: GestureType[]\r\n) {\r\n  gestureConfig?.prepare();\r\n\r\n  for (let i = 0; i < gesture.length; i++) {\r\n    const handler = preparedGesture.config[i];\r\n\r\n    // only update handlerTag when it's actually different, it may be the same\r\n    // if gesture config object is wrapped with useMemo\r\n    if (gesture[i].handlerTag !== handler.handlerTag) {\r\n      gesture[i].handlerTag = handler.handlerTag;\r\n      gesture[i].handlers.handlerTag = handler.handlerTag;\r\n    }\r\n  }\r\n\r\n  // use setImmediate to extract handlerTags, because when it's ran, all refs should be updated\r\n  // and handlerTags in BaseGesture references should be updated in the loop above (we need to wait\r\n  // in case of external relations)\r\n  setImmediate(() => {\r\n    for (let i = 0; i < gesture.length; i++) {\r\n      const handler = preparedGesture.config[i];\r\n\r\n      handler.config = gesture[i].config;\r\n      handler.handlers = gesture[i].handlers;\r\n\r\n      const requireToFail = extractValidHandlerTags(\r\n        handler.config.requireToFail\r\n      );\r\n\r\n      const simultaneousWith = extractValidHandlerTags(\r\n        handler.config.simultaneousWith\r\n      );\r\n\r\n      RNGestureHandlerModule.updateGestureHandler(\r\n        handler.handlerTag,\r\n        filterConfig(handler.config, ALLOWED_PROPS, {\r\n          simultaneousHandlers: simultaneousWith,\r\n          waitFor: requireToFail,\r\n        })\r\n      );\r\n\r\n      registerHandler(handler.handlerTag, handler, handler.config.testId);\r\n    }\r\n\r\n    if (preparedGesture.animatedHandlers) {\r\n      preparedGesture.animatedHandlers.value = (preparedGesture.config.map(\r\n        (g) => g.handlers\r\n      ) as unknown) as HandlerCallbacks<Record<string, unknown>>[];\r\n    }\r\n  });\r\n}\r\n\r\nfunction needsToReattach(\r\n  preparedGesture: GestureConfigReference,\r\n  gesture: GestureType[]\r\n) {\r\n  if (gesture.length !== preparedGesture.config.length) {\r\n    return true;\r\n  }\r\n  for (let i = 0; i < gesture.length; i++) {\r\n    if (gesture[i].handlerName !== preparedGesture.config[i].handlerName) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction useAnimatedGesture(\r\n  preparedGesture: GestureConfigReference,\r\n  needsRebuild: boolean\r\n) {\r\n  if (!Reanimated) {\r\n    return;\r\n  }\r\n\r\n  function isStateChangeEvent(\r\n    event: GestureUpdateEvent | GestureStateChangeEvent | GestureTouchEvent\r\n  ): event is GestureStateChangeEvent {\r\n    'worklet';\r\n    // @ts-ignore Yes, the oldState prop is missing on GestureTouchEvent, that's the point\r\n    return event.oldState != null;\r\n  }\r\n\r\n  function isTouchEvent(\r\n    event: GestureUpdateEvent | GestureStateChangeEvent | GestureTouchEvent\r\n  ): event is GestureTouchEvent {\r\n    'worklet';\r\n    return event.eventType != null;\r\n  }\r\n\r\n  function getHandler(\r\n    type: CALLBACK_TYPE,\r\n    gesture: HandlerCallbacks<Record<string, unknown>>\r\n  ) {\r\n    'worklet';\r\n    switch (type) {\r\n      case CALLBACK_TYPE.BEGAN:\r\n        return gesture.onBegin;\r\n      case CALLBACK_TYPE.START:\r\n        return gesture.onStart;\r\n      case CALLBACK_TYPE.UPDATE:\r\n        return gesture.onUpdate;\r\n      case CALLBACK_TYPE.CHANGE:\r\n        return gesture.onChange;\r\n      case CALLBACK_TYPE.END:\r\n        return gesture.onEnd;\r\n      case CALLBACK_TYPE.FINALIZE:\r\n        return gesture.onFinalize;\r\n      case CALLBACK_TYPE.TOUCHES_DOWN:\r\n        return gesture.onTouchesDown;\r\n      case CALLBACK_TYPE.TOUCHES_MOVE:\r\n        return gesture.onTouchesMove;\r\n      case CALLBACK_TYPE.TOUCHES_UP:\r\n        return gesture.onTouchesUp;\r\n      case CALLBACK_TYPE.TOUCHES_CANCELLED:\r\n        return gesture.onTouchesCancelled;\r\n    }\r\n  }\r\n\r\n  function touchEventTypeToCallbackType(eventType: EventType): CALLBACK_TYPE {\r\n    'worklet';\r\n    switch (eventType) {\r\n      case EventType.TOUCHES_DOWN:\r\n        return CALLBACK_TYPE.TOUCHES_DOWN;\r\n      case EventType.TOUCHES_MOVE:\r\n        return CALLBACK_TYPE.TOUCHES_MOVE;\r\n      case EventType.TOUCHES_UP:\r\n        return CALLBACK_TYPE.TOUCHES_UP;\r\n      case EventType.TOUCHES_CANCELLED:\r\n        return CALLBACK_TYPE.TOUCHES_CANCELLED;\r\n    }\r\n    return CALLBACK_TYPE.UNDEFINED;\r\n  }\r\n\r\n  function runWorklet(\r\n    type: CALLBACK_TYPE,\r\n    gesture: HandlerCallbacks<Record<string, unknown>>,\r\n    event: GestureStateChangeEvent | GestureUpdateEvent | GestureTouchEvent,\r\n    ...args: any[]\r\n  ) {\r\n    'worklet';\r\n    const handler = getHandler(type, gesture);\r\n    if (gesture.isWorklet[type]) {\r\n      // @ts-ignore Logic below makes sure the correct event is send to the\r\n      // correct handler.\r\n      handler?.(event, ...args);\r\n    } else if (handler) {\r\n      console.warn('Animated gesture callback must be a worklet');\r\n    }\r\n  }\r\n\r\n  // Hooks are called conditionally, but the condition is whether the\r\n  // react-native-reanimated is installed, which shouldn't change while running\r\n  // eslint-disable-next-line react-hooks/rules-of-hooks\r\n  const sharedHandlersCallbacks = Reanimated.useSharedValue<\r\n    HandlerCallbacks<Record<string, unknown>>[] | null\r\n  >(null);\r\n\r\n  // eslint-disable-next-line react-hooks/rules-of-hooks\r\n  const lastUpdateEvent = Reanimated.useSharedValue<\r\n    (GestureUpdateEvent | undefined)[]\r\n  >([]);\r\n\r\n  // not every gesture needs a state controller, init them lazily\r\n  const stateControllers: GestureStateManagerType[] = [];\r\n\r\n  const callback = (\r\n    event: GestureStateChangeEvent | GestureUpdateEvent | GestureTouchEvent\r\n  ) => {\r\n    'worklet';\r\n\r\n    const currentCallback = sharedHandlersCallbacks.value;\r\n    if (!currentCallback) {\r\n      return;\r\n    }\r\n\r\n    for (let i = 0; i < currentCallback.length; i++) {\r\n      const gesture = currentCallback[i];\r\n\r\n      if (event.handlerTag === gesture.handlerTag) {\r\n        if (isStateChangeEvent(event)) {\r\n          if (\r\n            event.oldState === State.UNDETERMINED &&\r\n            event.state === State.BEGAN\r\n          ) {\r\n            runWorklet(CALLBACK_TYPE.BEGAN, gesture, event);\r\n          } else if (\r\n            (event.oldState === State.BEGAN ||\r\n              event.oldState === State.UNDETERMINED) &&\r\n            event.state === State.ACTIVE\r\n          ) {\r\n            runWorklet(CALLBACK_TYPE.START, gesture, event);\r\n            lastUpdateEvent.value[gesture.handlerTag] = undefined;\r\n          } else if (\r\n            event.oldState !== event.state &&\r\n            event.state === State.END\r\n          ) {\r\n            if (event.oldState === State.ACTIVE) {\r\n              runWorklet(CALLBACK_TYPE.END, gesture, event, true);\r\n            }\r\n            runWorklet(CALLBACK_TYPE.FINALIZE, gesture, event, true);\r\n          } else if (\r\n            (event.state === State.FAILED || event.state === State.CANCELLED) &&\r\n            event.state !== event.oldState\r\n          ) {\r\n            if (event.oldState === State.ACTIVE) {\r\n              runWorklet(CALLBACK_TYPE.END, gesture, event, false);\r\n            }\r\n            runWorklet(CALLBACK_TYPE.FINALIZE, gesture, event, false);\r\n          }\r\n        } else if (isTouchEvent(event)) {\r\n          if (!stateControllers[i]) {\r\n            stateControllers[i] = GestureStateManager.create(event.handlerTag);\r\n          }\r\n\r\n          if (event.eventType !== EventType.UNDETERMINED) {\r\n            runWorklet(\r\n              touchEventTypeToCallbackType(event.eventType),\r\n              gesture,\r\n              event,\r\n              stateControllers[i]\r\n            );\r\n          }\r\n        } else {\r\n          runWorklet(CALLBACK_TYPE.UPDATE, gesture, event);\r\n\r\n          if (gesture.onChange && gesture.changeEventCalculator) {\r\n            runWorklet(\r\n              CALLBACK_TYPE.CHANGE,\r\n              gesture,\r\n              gesture.changeEventCalculator?.(\r\n                event,\r\n                lastUpdateEvent.value[gesture.handlerTag]\r\n              )\r\n            );\r\n\r\n            lastUpdateEvent.value[gesture.handlerTag] = event;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  // eslint-disable-next-line react-hooks/rules-of-hooks\r\n  const event = Reanimated.useEvent(\r\n    callback,\r\n    ['onGestureHandlerStateChange', 'onGestureHandlerEvent'],\r\n    needsRebuild\r\n  );\r\n\r\n  preparedGesture.animatedEventHandler = event;\r\n  preparedGesture.animatedHandlers = sharedHandlersCallbacks;\r\n}\r\n\r\ninterface GestureDetectorProps {\r\n  gesture?: ComposedGesture | GestureType;\r\n}\r\nexport const GestureDetector: React.FunctionComponent<GestureDetectorProps> = (\r\n  props\r\n) => {\r\n  const gestureConfig = props.gesture;\r\n  const gesture = gestureConfig?.toGestureArray?.() ?? [];\r\n  const useAnimated =\r\n    gesture.find((gesture) =>\r\n      gesture.handlers.isWorklet.reduce((prev, current) => prev || current)\r\n    ) != null;\r\n  const viewRef = useRef(null);\r\n  const firstRenderRef = useRef(true);\r\n\r\n  const preparedGesture = React.useRef<GestureConfigReference>({\r\n    config: gesture,\r\n    animatedEventHandler: null,\r\n    animatedHandlers: null,\r\n    firstExecution: true,\r\n    useAnimated: useAnimated,\r\n  }).current;\r\n\r\n  if (useAnimated !== preparedGesture.useAnimated) {\r\n    throw new Error(\r\n      'You cannot change whether you are using gesture or animatedGesture while the app is running'\r\n    );\r\n  }\r\n\r\n  // Reanimated event should be rebuilt only when gestures are reattached, otherwise\r\n  // config update will be enough as all necessary items are stored in shared values anyway\r\n  const needsToRebuildReanimatedEvent =\r\n    preparedGesture.firstExecution || needsToReattach(preparedGesture, gesture);\r\n\r\n  if (preparedGesture.firstExecution) {\r\n    gestureConfig?.initialize?.();\r\n  }\r\n\r\n  if (useAnimated) {\r\n    // Whether animatedGesture or gesture is used shouldn't change\r\n    // during while an app is running\r\n    // eslint-disable-next-line react-hooks/rules-of-hooks\r\n    useAnimatedGesture(preparedGesture, needsToRebuildReanimatedEvent);\r\n  }\r\n\r\n  useEffect(() => {\r\n    firstRenderRef.current = true;\r\n    const viewTag = findNodeHandle(viewRef.current) as number;\r\n    attachHandlers({\r\n      preparedGesture,\r\n      gestureConfig,\r\n      gesture,\r\n      viewTag,\r\n      useAnimated,\r\n    });\r\n\r\n    return () => {\r\n      dropHandlers(preparedGesture);\r\n    };\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    if (!firstRenderRef.current) {\r\n      const viewTag = findNodeHandle(viewRef.current) as number;\r\n\r\n      if (needsToReattach(preparedGesture, gesture)) {\r\n        dropHandlers(preparedGesture);\r\n        attachHandlers({\r\n          preparedGesture,\r\n          gestureConfig,\r\n          gesture,\r\n          viewTag,\r\n          useAnimated,\r\n        });\r\n      } else {\r\n        updateHandlers(preparedGesture, gestureConfig, gesture);\r\n      }\r\n    } else {\r\n      firstRenderRef.current = false;\r\n    }\r\n  }, [props]);\r\n\r\n  if (useAnimated) {\r\n    return (\r\n      <AnimatedWrap\r\n        ref={viewRef}\r\n        onGestureHandlerEvent={preparedGesture.animatedEventHandler}>\r\n        {props.children}\r\n      </AnimatedWrap>\r\n    );\r\n  } else {\r\n    return <Wrap ref={viewRef}>{props.children}</Wrap>;\r\n  }\r\n};\r\n\r\nclass Wrap extends React.Component<{ onGestureHandlerEvent?: unknown }> {\r\n  render() {\r\n    // I don't think that fighting with types over such a simple function is worth it\r\n    // The only thing it does is add 'collapsable: false' to the child component\r\n    // to make sure it is in the native view hierarchy so the detector can find\r\n    // correct viewTag to attach to.\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    const child: any = React.Children.only(this.props.children);\r\n\r\n    return React.cloneElement(\r\n      child,\r\n      { collapsable: false },\r\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\r\n      child.props.children\r\n    );\r\n  }\r\n}\r\n\r\nconst AnimatedWrap = Reanimated?.default?.createAnimatedComponent(Wrap) ?? Wrap;\r\n"]}