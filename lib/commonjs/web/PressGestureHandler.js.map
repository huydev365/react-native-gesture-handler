{"version":3,"sources":["PressGestureHandler.ts"],"names":["PressGestureHandler","DiscreteGestureHandler","name","minDurationMs","config","maxDist","NativeGestureClass","Hammer","Press","simulateCancelEvent","inputData","hasGestureFailed","cancelEvent","updateHasCustomActivationCriteria","shouldCancelWhenOutside","maxDistSq","getState","type","INPUT_START","State","BEGAN","INPUT_MOVE","ACTIVE","INPUT_END","END","INPUT_CANCEL","CANCELLED","getConfig","hasCustomActivationCriteria","getHammerConfig","time","onGestureActivated","ev","onGestureStart","shouldDelayTouchForEvent","pointerType","shouldDelayTouches","isGestureRunning","clearTimeout","visualFeedbackTimer","initialEvent","sendGestureStartedEvent","CONTENT_TOUCHES_DELAY","sendEvent","eventType","isFirst","forceInvalidate","event","onRawEvent","isFinal","timeout","CONTENT_TOUCHES_QUICK_TAP_END_DELAY","onGestureEnded","updateGestureConfig","shouldActivateOnStart","disallowInterruption","Number","NaN","minPointers","maxPointers","props"],"mappings":"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","sourcesContent":["import Hammer from '@egjs/hammerjs';\r\n\r\nimport { State } from '../State';\r\nimport {\r\n  CONTENT_TOUCHES_DELAY,\r\n  CONTENT_TOUCHES_QUICK_TAP_END_DELAY,\r\n  HammerInputNames,\r\n} from './constants';\r\nimport DiscreteGestureHandler from './DiscreteGestureHandler';\r\nimport { Config, HammerInputExt } from './GestureHandler';\r\nimport { fireAfterInterval, isValidNumber, isnan } from './utils';\r\n\r\nclass PressGestureHandler extends DiscreteGestureHandler {\r\n  private visualFeedbackTimer: any;\r\n  private initialEvent: HammerInputExt | null = null;\r\n  get name() {\r\n    return 'press';\r\n  }\r\n\r\n  get minDurationMs() {\r\n    // @ts-ignore FIXME(TS)\r\n    return isnan(this.config.minDurationMs) ? 5 : this.config.minDurationMs;\r\n  }\r\n\r\n  get maxDist() {\r\n    return isnan(this.config.maxDist) ? 9 : this.config.maxDist;\r\n  }\r\n\r\n  get NativeGestureClass() {\r\n    return Hammer.Press;\r\n  }\r\n\r\n  shouldDelayTouches = true;\r\n\r\n  simulateCancelEvent(inputData: HammerInputExt) {\r\n    // Long press never starts so we can't rely on the running event boolean.\r\n    this.hasGestureFailed = true;\r\n    this.cancelEvent(inputData);\r\n  }\r\n\r\n  updateHasCustomActivationCriteria({\r\n    shouldCancelWhenOutside,\r\n    maxDistSq,\r\n  }: Config & { shouldCancelWhenOutside: boolean }) {\r\n    return shouldCancelWhenOutside || !isValidNumber(maxDistSq);\r\n  }\r\n\r\n  getState(type: keyof typeof HammerInputNames): State {\r\n    return {\r\n      [Hammer.INPUT_START]: State.BEGAN,\r\n      [Hammer.INPUT_MOVE]: State.ACTIVE,\r\n      [Hammer.INPUT_END]: State.END,\r\n      [Hammer.INPUT_CANCEL]: State.CANCELLED,\r\n    }[type];\r\n  }\r\n\r\n  getConfig() {\r\n    if (!this.hasCustomActivationCriteria) {\r\n      // Default config\r\n      // If no params have been defined then this config should emulate the native gesture as closely as possible.\r\n      return {\r\n        shouldCancelWhenOutside: true,\r\n        maxDistSq: 10,\r\n      };\r\n    }\r\n    return this.config;\r\n  }\r\n\r\n  getHammerConfig() {\r\n    return {\r\n      ...super.getHammerConfig(),\r\n      // threshold: this.maxDist,\r\n      time: this.minDurationMs,\r\n    };\r\n  }\r\n\r\n  onGestureActivated(ev: HammerInputExt) {\r\n    this.onGestureStart(ev);\r\n  }\r\n\r\n  shouldDelayTouchForEvent({ pointerType }: HammerInputExt) {\r\n    // Don't disable event for mouse input\r\n    return this.shouldDelayTouches && pointerType === 'touch';\r\n  }\r\n\r\n  onGestureStart(ev: HammerInputExt) {\r\n    this.isGestureRunning = true;\r\n    clearTimeout(this.visualFeedbackTimer);\r\n    this.initialEvent = ev;\r\n    this.visualFeedbackTimer = fireAfterInterval(() => {\r\n      this.sendGestureStartedEvent(this.initialEvent as HammerInputExt);\r\n      this.initialEvent = null;\r\n    }, this.shouldDelayTouchForEvent(ev) && CONTENT_TOUCHES_DELAY);\r\n  }\r\n\r\n  sendGestureStartedEvent(ev: HammerInputExt) {\r\n    clearTimeout(this.visualFeedbackTimer);\r\n    this.visualFeedbackTimer = null;\r\n    this.sendEvent({\r\n      ...ev,\r\n      eventType: Hammer.INPUT_MOVE,\r\n      isFirst: true,\r\n    });\r\n  }\r\n\r\n  forceInvalidate(event: HammerInputExt) {\r\n    super.forceInvalidate(event);\r\n    clearTimeout(this.visualFeedbackTimer);\r\n    this.visualFeedbackTimer = null;\r\n    this.initialEvent = null;\r\n  }\r\n\r\n  onRawEvent(ev: HammerInputExt) {\r\n    super.onRawEvent(ev);\r\n    if (this.isGestureRunning) {\r\n      if (ev.isFinal) {\r\n        let timeout;\r\n        if (this.visualFeedbackTimer) {\r\n          // Aesthetic timing for a quick tap.\r\n          // We haven't activated the tap right away to emulate iOS `delaysContentTouches`\r\n          // Now we must send the initial activation event and wait a set amount of time before firing the end event.\r\n          timeout = CONTENT_TOUCHES_QUICK_TAP_END_DELAY;\r\n          this.sendGestureStartedEvent(this.initialEvent as HammerInputExt);\r\n          this.initialEvent = null;\r\n        }\r\n        fireAfterInterval(() => {\r\n          this.sendEvent({\r\n            ...ev,\r\n            eventType: Hammer.INPUT_END,\r\n            isFinal: true,\r\n          });\r\n          // @ts-ignore -- this should explicitly support undefined\r\n          this.onGestureEnded();\r\n        }, timeout);\r\n      } else {\r\n        this.sendEvent({\r\n          ...ev,\r\n          eventType: Hammer.INPUT_MOVE,\r\n          isFinal: false,\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  updateGestureConfig({\r\n    shouldActivateOnStart = false,\r\n    disallowInterruption = false,\r\n    shouldCancelWhenOutside = true,\r\n    minDurationMs = Number.NaN,\r\n    maxDist = Number.NaN,\r\n    minPointers = 1,\r\n    maxPointers = 1,\r\n    ...props\r\n  }) {\r\n    return super.updateGestureConfig({\r\n      shouldActivateOnStart,\r\n      disallowInterruption,\r\n      shouldCancelWhenOutside,\r\n      minDurationMs,\r\n      maxDist,\r\n      minPointers,\r\n      maxPointers,\r\n      ...props,\r\n    });\r\n  }\r\n}\r\nexport default PressGestureHandler;\r\n"]}