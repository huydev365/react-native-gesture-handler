{"version":3,"sources":["FlingGestureHandler.ts"],"names":["FlingGestureHandler","DraggingGestureHandler","name","NativeGestureClass","Hammer","Swipe","onGestureActivated","event","sendEvent","eventType","INPUT_MOVE","isFinal","isFirst","isGestureRunning","hasGestureFailed","INPUT_END","onRawEvent","ev","setTimeout","cancelEvent","gesture","hammer","get","options","enable","onStart","getHammerConfig","pointers","config","numberOfPointers","direction","getDirection","getTargetDirections","directions","Direction","RIGHT","push","DIRECTION_RIGHT","LEFT","DIRECTION_LEFT","UP","DIRECTION_UP","DOWN","DIRECTION_DOWN","getConfig","DIRECTION_HORIZONTAL","DIRECTION_VERTICAL","Set","length","DIRECTION_NONE","DIRECTION_ALL","isGestureEnabledForEvent","_recognizer","maxPointers","pointerLength","validPointerCount","failed","success","updateGestureConfig","props","GesturePropError"],"mappings":"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","sourcesContent":["/* eslint-disable eslint-comments/no-unlimited-disable */\r\n/* eslint-disable */\r\nimport Hammer from '@egjs/hammerjs';\r\n\r\nimport { Direction } from './constants';\r\nimport { GesturePropError } from './Errors';\r\nimport DraggingGestureHandler from './DraggingGestureHandler';\r\nimport { isnan } from './utils';\r\nimport { HammerInputExt } from './GestureHandler';\r\n\r\nclass FlingGestureHandler extends DraggingGestureHandler {\r\n  get name() {\r\n    return 'swipe';\r\n  }\r\n\r\n  get NativeGestureClass() {\r\n    return Hammer.Swipe;\r\n  }\r\n\r\n  onGestureActivated(event: HammerInputExt) {\r\n    this.sendEvent({\r\n      ...event,\r\n      eventType: Hammer.INPUT_MOVE,\r\n      isFinal: false,\r\n      isFirst: true,\r\n    });\r\n    this.isGestureRunning = false;\r\n    this.hasGestureFailed = false;\r\n    this.sendEvent({\r\n      ...event,\r\n      eventType: Hammer.INPUT_END,\r\n      isFinal: true,\r\n    });\r\n  }\r\n\r\n  onRawEvent(ev: HammerInputExt) {\r\n    super.onRawEvent(ev);\r\n    if (this.hasGestureFailed) {\r\n      return;\r\n    }\r\n    // Hammer doesn't send a `cancel` event for taps.\r\n    // Manually fail the event.\r\n    if (ev.isFinal) {\r\n      setTimeout(() => {\r\n        if (this.isGestureRunning) {\r\n          this.cancelEvent(ev);\r\n        }\r\n      });\r\n    } else if (!this.hasGestureFailed && !this.isGestureRunning) {\r\n      // Tap Gesture start event\r\n      const gesture = this.hammer!.get(this.name);\r\n      // @ts-ignore FIXME(TS)\r\n      if (gesture.options.enable(gesture, ev)) {\r\n        this.onStart(ev);\r\n        this.sendEvent(ev);\r\n      }\r\n    }\r\n  }\r\n\r\n  getHammerConfig() {\r\n    return {\r\n      // @ts-ignore FIXME(TS)\r\n      pointers: this.config.numberOfPointers,\r\n      direction: this.getDirection(),\r\n    };\r\n  }\r\n\r\n  getTargetDirections(direction: number) {\r\n    const directions = [];\r\n    if (direction & Direction.RIGHT) {\r\n      directions.push(Hammer.DIRECTION_RIGHT);\r\n    }\r\n    if (direction & Direction.LEFT) {\r\n      directions.push(Hammer.DIRECTION_LEFT);\r\n    }\r\n    if (direction & Direction.UP) {\r\n      directions.push(Hammer.DIRECTION_UP);\r\n    }\r\n    if (direction & Direction.DOWN) {\r\n      directions.push(Hammer.DIRECTION_DOWN);\r\n    }\r\n    // const hammerDirection = directions.reduce((a, b) => a | b, 0);\r\n    return directions;\r\n  }\r\n\r\n  getDirection() {\r\n    // @ts-ignore FIXME(TS)\r\n    const { direction } = this.getConfig();\r\n\r\n    let directions = [];\r\n    if (direction & Direction.RIGHT) {\r\n      directions.push(Hammer.DIRECTION_HORIZONTAL);\r\n    }\r\n    if (direction & Direction.LEFT) {\r\n      directions.push(Hammer.DIRECTION_HORIZONTAL);\r\n    }\r\n    if (direction & Direction.UP) {\r\n      directions.push(Hammer.DIRECTION_VERTICAL);\r\n    }\r\n    if (direction & Direction.DOWN) {\r\n      directions.push(Hammer.DIRECTION_VERTICAL);\r\n    }\r\n    directions = [...new Set(directions)];\r\n\r\n    if (directions.length === 0) return Hammer.DIRECTION_NONE;\r\n    if (directions.length === 1) return directions[0];\r\n    return Hammer.DIRECTION_ALL;\r\n  }\r\n\r\n  isGestureEnabledForEvent(\r\n    { numberOfPointers }: any,\r\n    _recognizer: any,\r\n    { maxPointers: pointerLength }: any\r\n  ) {\r\n    const validPointerCount = pointerLength === numberOfPointers;\r\n    if (!validPointerCount && this.isGestureRunning) {\r\n      return { failed: true };\r\n    }\r\n    return { success: validPointerCount };\r\n  }\r\n\r\n  updateGestureConfig({ numberOfPointers = 1, direction, ...props }: any) {\r\n    if (isnan(direction) || typeof direction !== 'number') {\r\n      throw new GesturePropError('direction', direction, 'number');\r\n    }\r\n    return super.updateGestureConfig({\r\n      numberOfPointers,\r\n      direction,\r\n      ...props,\r\n    });\r\n  }\r\n}\r\n\r\nexport default FlingGestureHandler;\r\n"]}