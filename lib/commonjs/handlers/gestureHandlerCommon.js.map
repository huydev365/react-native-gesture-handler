{"version":3,"sources":["gestureHandlerCommon.ts"],"names":["commonProps","componentInteractionProps","baseGestureHandlerProps","baseGestureHandlerWithMonitorProps","isConfigParam","param","name","undefined","Object","filterConfig","props","validProps","defaults","filteredConfig","key","value","transformIntoHandlerTags","top","left","bottom","right","handlerIDs","Platform","OS","map","current","filter","handle","handlerID","handlerIDToTag","handlerTag","findNodeHandle","node"],"mappings":";;;;;;;;;AAKA;;AAKA;;AACA;;AAXA;AACA;AACA;AACA;AAUA,MAAMA,WAAW,GAAG,CAClB,IADkB,EAElB,SAFkB,EAGlB,yBAHkB,EAIlB,SAJkB,CAApB;AAOA,MAAMC,yBAAyB,GAAG,CAAC,SAAD,EAAY,sBAAZ,CAAlC;AAEO,MAAMC,uBAAuB,GAAG,CACrC,GAAGF,WADkC,EAErC,GAAGC,yBAFkC,EAGrC,SAHqC,EAIrC,UAJqC,EAKrC,aALqC,EAMrC,aANqC,EAOrC,SAPqC,EAQrC,gBARqC,EASrC,sBATqC,CAAhC;;AAYA,MAAME,kCAAkC,GAAG,CAChD,GAAGH,WAD6C,EAEhD,kBAFgD,EAGhD,kBAHgD,CAA3C;;;AA6FP,SAASI,aAAT,CAAuBC,KAAvB,EAAuCC,IAAvC,EAAqD;AACnD;AACA;AACA,SACED,KAAK,KAAKE,SAAV,KACCF,KAAK,KAAKG,MAAM,CAACH,KAAD,CAAhB,IACC,EAAE,gBAAiBA,KAAnB,CAFF,KAGAC,IAAI,KAAK,sBAHT,IAIAA,IAAI,KAAK,gBALX;AAOD;;AAEM,SAASG,YAAT,CACLC,KADK,EAELC,UAFK,EAGLC,QAAiC,GAAG,EAH/B,EAIL;AACA,QAAMC,cAAc,GAAG,EAAE,GAAGD;AAAL,GAAvB;;AACA,OAAK,MAAME,GAAX,IAAkBH,UAAlB,EAA8B;AAC5B,QAAII,KAAK,GAAGL,KAAK,CAACI,GAAD,CAAjB;;AACA,QAAIV,aAAa,CAACW,KAAD,EAAQD,GAAR,CAAjB,EAA+B;AAC7B,UAAIA,GAAG,KAAK,sBAAR,IAAkCA,GAAG,KAAK,SAA9C,EAAyD;AACvDC,QAAAA,KAAK,GAAGC,wBAAwB,CAACN,KAAK,CAACI,GAAD,CAAN,CAAhC;AACD,OAFD,MAEO,IAAIA,GAAG,KAAK,SAAR,IAAqB,OAAOC,KAAP,KAAiB,QAA1C,EAAoD;AACzDA,QAAAA,KAAK,GAAG;AAAEE,UAAAA,GAAG,EAAEF,KAAP;AAAcG,UAAAA,IAAI,EAAEH,KAApB;AAA2BI,UAAAA,MAAM,EAAEJ,KAAnC;AAA0CK,UAAAA,KAAK,EAAEL;AAAjD,SAAR;AACD;;AACDF,MAAAA,cAAc,CAACC,GAAD,CAAd,GAAsBC,KAAtB;AACD;AACF;;AACD,SAAOF,cAAP;AACD;;AAED,SAASG,wBAAT,CAAkCK,UAAlC,EAAmD;AACjDA,EAAAA,UAAU,GAAG,oBAAQA,UAAR,CAAb;;AAEA,MAAIC,sBAASC,EAAT,KAAgB,KAApB,EAA2B;AACzB,WAAOF,UAAU,CACdG,GADI,CACA,CAAC;AAAEC,MAAAA;AAAF,KAAD,KAAmCA,OADnC,EAEJC,MAFI,CAEIC,MAAD,IAAiBA,MAFpB,CAAP;AAGD,GAPgD,CAQjD;;;AACA,SAAON,UAAU,CACdG,GADI,CAEFI,SAAD;AAAA;;AAAA,WACEC,iCAAeD,SAAf,4BAA6BA,SAAS,CAACH,OAAvC,uDAA6B,mBAAmBK,UAAhD,KAA8D,CAAC,CADjE;AAAA,GAFG,EAKJJ,MALI,CAKII,UAAD,IAAwBA,UAAU,GAAG,CALxC,CAAP;AAMD;;AAEM,SAASC,cAAT,CACLC,IADK,EAEkE;AACvE,MAAIV,sBAASC,EAAT,KAAgB,KAApB,EAA2B,OAAOS,IAAP;AAC3B,SAAO,iCAAiBA,IAAjB,CAAP;AACD","sourcesContent":["// Previous types exported gesture handlers as classes which creates an interface and variable, both named the same as class.\r\n// Without those types, we'd introduce breaking change, forcing users to prefix every handler type specification with typeof\r\n// e.g. React.createRef<TapGestureHandler> -> React.createRef<typeof TapGestureHandler>.\r\n// See https://www.typescriptlang.org/docs/handbook/classes.html#constructor-functions for reference.\r\nimport * as React from 'react';\r\nimport { Platform, findNodeHandle as findNodeHandleRN } from 'react-native';\r\n\r\nimport { State } from '../State';\r\nimport { EventType } from '../EventType';\r\nimport { ValueOf } from '../typeUtils';\r\nimport { handlerIDToTag } from './handlersRegistry';\r\nimport { toArray } from '../utils';\r\n\r\nconst commonProps = [\r\n  'id',\r\n  'enabled',\r\n  'shouldCancelWhenOutside',\r\n  'hitSlop',\r\n] as const;\r\n\r\nconst componentInteractionProps = ['waitFor', 'simultaneousHandlers'] as const;\r\n\r\nexport const baseGestureHandlerProps = [\r\n  ...commonProps,\r\n  ...componentInteractionProps,\r\n  'onBegan',\r\n  'onFailed',\r\n  'onCancelled',\r\n  'onActivated',\r\n  'onEnded',\r\n  'onGestureEvent',\r\n  'onHandlerStateChange',\r\n] as const;\r\n\r\nexport const baseGestureHandlerWithMonitorProps = [\r\n  ...commonProps,\r\n  'needsPointerData',\r\n  'manualActivation',\r\n];\r\n\r\nexport interface GestureEventPayload {\r\n  handlerTag: number;\r\n  numberOfPointers: number;\r\n  state: ValueOf<typeof State>;\r\n}\r\nexport interface HandlerStateChangeEventPayload extends GestureEventPayload {\r\n  oldState: ValueOf<typeof State>;\r\n}\r\n\r\nexport type HitSlop =\r\n  | number\r\n  | Partial<\r\n      Record<\r\n        'left' | 'right' | 'top' | 'bottom' | 'vertical' | 'horizontal',\r\n        number\r\n      >\r\n    >\r\n  | Record<'width' | 'left', number>\r\n  | Record<'width' | 'right', number>\r\n  | Record<'height' | 'top', number>\r\n  | Record<'height' | 'bottom', number>;\r\n\r\n//TODO(TS) events in handlers\r\n\r\nexport interface GestureEvent<ExtraEventPayloadT = Record<string, unknown>> {\r\n  nativeEvent: Readonly<GestureEventPayload & ExtraEventPayloadT>;\r\n}\r\nexport interface HandlerStateChangeEvent<\r\n  ExtraEventPayloadT = Record<string, unknown>\r\n> {\r\n  nativeEvent: Readonly<HandlerStateChangeEventPayload & ExtraEventPayloadT>;\r\n}\r\n\r\nexport type TouchData = {\r\n  id: number;\r\n  x: number;\r\n  y: number;\r\n  absoluteX: number;\r\n  absoluteY: number;\r\n};\r\n\r\nexport type GestureTouchEvent = {\r\n  handlerTag: number;\r\n  numberOfTouches: number;\r\n  state: ValueOf<typeof State>;\r\n  eventType: EventType;\r\n  allTouches: TouchData[];\r\n  changedTouches: TouchData[];\r\n};\r\n\r\nexport type GestureUpdateEvent<\r\n  GestureEventPayloadT = Record<string, unknown>\r\n> = GestureEventPayload & GestureEventPayloadT;\r\n\r\nexport type GestureStateChangeEvent<\r\n  GestureStateChangeEventPayloadT = Record<string, unknown>\r\n> = HandlerStateChangeEventPayload & GestureStateChangeEventPayloadT;\r\n\r\nexport type CommonGestureConfig = {\r\n  enabled?: boolean;\r\n  shouldCancelWhenOutside?: boolean;\r\n  hitSlop?: HitSlop;\r\n};\r\n\r\n// Events payloads are types instead of interfaces due to TS limitation.\r\n// See https://github.com/microsoft/TypeScript/issues/15300 for more info.\r\nexport type BaseGestureHandlerProps<\r\n  ExtraEventPayloadT extends Record<string, unknown> = Record<string, unknown>\r\n> = CommonGestureConfig & {\r\n  id?: string;\r\n  waitFor?: React.Ref<unknown> | React.Ref<unknown>[];\r\n  simultaneousHandlers?: React.Ref<unknown> | React.Ref<unknown>[];\r\n  testID?: string;\r\n  // TODO(TS) - fix event types\r\n  onBegan?: (event: HandlerStateChangeEvent) => void;\r\n  onFailed?: (event: HandlerStateChangeEvent) => void;\r\n  onCancelled?: (event: HandlerStateChangeEvent) => void;\r\n  onActivated?: (event: HandlerStateChangeEvent) => void;\r\n  onEnded?: (event: HandlerStateChangeEvent) => void;\r\n\r\n  //TODO(TS) consider using NativeSyntheticEvent\r\n  onGestureEvent?: (event: GestureEvent<ExtraEventPayloadT>) => void;\r\n  onHandlerStateChange?: (\r\n    event: HandlerStateChangeEvent<ExtraEventPayloadT>\r\n  ) => void;\r\n};\r\n\r\nfunction isConfigParam(param: unknown, name: string) {\r\n  // param !== Object(param) returns false if `param` is a function\r\n  // or an object and returns true if `param` is null\r\n  return (\r\n    param !== undefined &&\r\n    (param !== Object(param) ||\r\n      !('__isNative' in (param as Record<string, unknown>))) &&\r\n    name !== 'onHandlerStateChange' &&\r\n    name !== 'onGestureEvent'\r\n  );\r\n}\r\n\r\nexport function filterConfig(\r\n  props: Record<string, unknown>,\r\n  validProps: string[],\r\n  defaults: Record<string, unknown> = {}\r\n) {\r\n  const filteredConfig = { ...defaults };\r\n  for (const key of validProps) {\r\n    let value = props[key];\r\n    if (isConfigParam(value, key)) {\r\n      if (key === 'simultaneousHandlers' || key === 'waitFor') {\r\n        value = transformIntoHandlerTags(props[key]);\r\n      } else if (key === 'hitSlop' && typeof value !== 'object') {\r\n        value = { top: value, left: value, bottom: value, right: value };\r\n      }\r\n      filteredConfig[key] = value;\r\n    }\r\n  }\r\n  return filteredConfig;\r\n}\r\n\r\nfunction transformIntoHandlerTags(handlerIDs: any) {\r\n  handlerIDs = toArray(handlerIDs);\r\n\r\n  if (Platform.OS === 'web') {\r\n    return handlerIDs\r\n      .map(({ current }: { current: any }) => current)\r\n      .filter((handle: any) => handle);\r\n  }\r\n  // converts handler string IDs into their numeric tags\r\n  return handlerIDs\r\n    .map(\r\n      (handlerID: any) =>\r\n        handlerIDToTag[handlerID] || handlerID.current?.handlerTag || -1\r\n    )\r\n    .filter((handlerTag: number) => handlerTag > 0);\r\n}\r\n\r\nexport function findNodeHandle(\r\n  node: null | number | React.Component<any, any> | React.ComponentClass<any>\r\n): null | number | React.Component<any, any> | React.ComponentClass<any> {\r\n  if (Platform.OS === 'web') return node;\r\n  return findNodeHandleRN(node);\r\n}\r\n"]}